use crate::{CameraIntrinsics, CameraMatrix, DistortionCoefs};
use anyhow::{ensure, Result};
#[cfg(all(feature = "with-opencv", feature = "with-nalgebra"))]
use cv_convert::{OpenCvPose, TryToCv};
#[cfg(feature = "with-nalgebra")]
use nalgebra as na;
use noisy_float::prelude::*;
#[cfg(feature = "with-opencv")]
use opencv::prelude::*;
use serde::{de::Error as _, Deserialize, Deserializer};
use std::mem;

/// The type defines the calibration parameter file generated by MRPT
/// camera-calib.
#[derive(Debug, Clone, Deserialize)]
pub struct MrptCalibration {
    pub camera_name: String,
    pub focal_length_meters: R64,
    pub image_height: usize,
    pub image_width: usize,
    pub distortion_model: DistortionModel,
    pub distortion_coefficients: Matrix,
    pub camera_matrix: Matrix,
    pub projection_matrix: Matrix,
    pub rectification_matrix: Matrix,
}

impl MrptCalibration {
    pub fn intrinsic_params(&self) -> Result<CameraIntrinsics> {
        use slice_of_array::prelude::*;

        let Self {
            camera_matrix,
            distortion_coefficients,
            ..
        } = self;

        ensure!(camera_matrix.rows == 3 && camera_matrix.cols == 3);
        ensure!(distortion_coefficients.rows == 1 && distortion_coefficients.cols >= 5);
        {
            let is_all_zero = distortion_coefficients
                .data
                .get(5..)
                .into_iter()
                .flatten()
                .all(|&val| val == 0.0);
            ensure!(is_all_zero);
        }

        let camera_matrix = CameraMatrix({
            let array: &[[R64; 3]] = camera_matrix.data().nest();
            array.try_into().unwrap()
        });
        let distortion_coefs =
            DistortionCoefs(distortion_coefficients.data()[0..5].try_into().unwrap());

        Ok(CameraIntrinsics {
            camera_matrix,
            distortion_coefs,
        })
    }
}

#[derive(Debug, Clone)]
pub struct Matrix {
    rows: usize,
    cols: usize,
    data: Vec<R64>,
}

impl Matrix {
    /// Converts the matrix to a OpenCV Mat.
    #[cfg(feature = "with-opencv")]
    pub fn to_opencv(&self) -> Mat {
        let mat = Mat::from_slice(self.data_f64()).unwrap();
        mat.reshape(1, self.rows as i32).unwrap()
    }

    #[cfg(feature = "with-nalgebra")]
    pub fn to_na(&self) -> na::DMatrix<f64> {
        na::DMatrix::from_row_slice(self.rows, self.cols, self.data_f64())
    }

    /// Get the matrix's rows.
    pub fn rows(&self) -> usize {
        self.rows
    }

    /// Get the matrix's cols.
    pub fn cols(&self) -> usize {
        self.cols
    }

    /// Get a R64 slice to the matrix's data.
    pub fn data(&self) -> &[R64] {
        self.data.as_ref()
    }

    /// Get a f64 slice to the matrix's data.
    pub fn data_f64(&self) -> &[f64] {
        unsafe { mem::transmute(self.data()) }
    }
}

impl<'de> Deserialize<'de> for Matrix {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let UncheckedMatrix { rows, cols, data } = UncheckedMatrix::deserialize(deserializer)?;
        if rows * cols != data.len() {
            return Err(D::Error::custom(format!(
                "data size ({}) does not match rows ({}) and cols ({})",
                data.len(),
                rows,
                cols
            )));
        }
        Ok(Self { rows, cols, data })
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct UncheckedMatrix {
    rows: usize,
    cols: usize,
    data: Vec<R64>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DistortionModel {
    PlumbBob,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ExtrinsicsData {
    Quaternion(ExtrinsicsTransform),
    Matrix(ExtrinsicsMatrix),
}

impl ExtrinsicsData {
    #[cfg(feature = "with-nalgebra")]
    pub fn to_na(&self) -> na::Isometry3<f64> {
        match self {
            Self::Quaternion(me) => me.to_na(),
            Self::Matrix(me) => me.to_na(),
        }
    }

    #[cfg(all(feature = "with-opencv", feature = "with-nalgebra"))]
    pub fn to_opencv(&self) -> Result<OpenCvPose<Mat>> {
        let pose = self.to_na().try_to_cv()?;
        Ok(pose)
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct ExtrinsicsTransform {
    pub rot_wijk: [R64; 4],
    pub trans_xyz: [R64; 3],
}

impl ExtrinsicsTransform {
    #[cfg(feature = "with-nalgebra")]
    pub fn to_na(&self) -> na::Isometry3<f64> {
        let Self {
            rot_wijk,
            trans_xyz,
        } = *self;
        let [w, i, j, k]: [f64; 4] = unsafe { mem::transmute(rot_wijk) };
        let [x, y, z]: [f64; 3] = unsafe { mem::transmute(trans_xyz) };

        let rotation = na::UnitQuaternion::from_quaternion(na::Quaternion::new(w, i, j, k));
        let translation = na::Translation3::new(x, y, z);

        na::Isometry3 {
            rotation,
            translation,
        }
    }
}

#[derive(Debug, Clone, Deserialize)]
pub struct ExtrinsicsMatrix {
    pub rot: [[R64; 3]; 3],
    pub trans: [R64; 3],
}

impl ExtrinsicsMatrix {
    #[cfg(feature = "with-nalgebra")]
    pub fn to_na(&self) -> na::Isometry3<f64> {
        use slice_of_array::prelude::*;

        let rotation = {
            let slice: &[R64] = self.rot.flat();
            let slice: &[f64] = unsafe { mem::transmute(slice) };
            let mat = na::Matrix3::from_row_slice(slice);
            na::UnitQuaternion::from_matrix(&mat)
        };
        let translation = {
            let [x, y, z]: [f64; 3] = unsafe { mem::transmute(self.trans) };
            na::Translation3::new(x, y, z)
        };
        na::Isometry3 {
            rotation,
            translation,
        }
    }
}
